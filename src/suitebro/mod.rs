use binrw::{BinRead, BinWrite, VecArgs};
use serde::{Deserialize, Serialize};

use crate::{
    byte_size::{ByteSize, StaticByteSize},
    gvas::types::FString,
};

use self::{item::Item, property_map::PropertyMap};

pub mod item;
pub mod property_map;

#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub struct Header {
    pub format_version: u32,
    pub unreal_version: u32,
}

const SUITEBRO_MAGIC: &[u8; 8] = b"suitebro";

impl BinRead for Header {
    type Args<'a> = ();

    fn read_options<R: std::io::prelude::Read + std::io::prelude::Seek>(
        reader: &mut R,
        endian: binrw::Endian,
        args: Self::Args<'_>,
    ) -> binrw::prelude::BinResult<Self> {
        let magic = <[u8; 8]>::read_options(reader, endian, args)?;

        if &magic != SUITEBRO_MAGIC {
            Err(binrw::Error::BadMagic {
                pos: reader.stream_position()?,
                found: Box::new(magic),
            })?;
        }

        Ok(Self {
            format_version: <_>::read_options(reader, endian, args)?,
            unreal_version: <_>::read_options(reader, endian, args)?,
        })
    }
}

impl BinWrite for Header {
    type Args<'a> = ();

    fn write_options<W: std::io::prelude::Write + std::io::prelude::Seek>(
        &self,
        writer: &mut W,
        endian: binrw::Endian,
        args: Self::Args<'_>,
    ) -> binrw::prelude::BinResult<()> {
        SUITEBRO_MAGIC.write_options(writer, endian, args)?;
        self.format_version.write_options(writer, endian, args)?;
        self.unreal_version.write_options(writer, endian, args)
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct PropertyList {
    pub name: FString,
    pub properties: PropertyMap,
}

impl BinRead for PropertyList {
    type Args<'a> = ();
    fn read_options<R: std::io::prelude::Read + std::io::prelude::Seek>(
        reader: &mut R,
        endian: binrw::Endian,
        args: Self::Args<'_>,
    ) -> binrw::prelude::BinResult<Self> {
        let name = FString::read_options(reader, endian, args)?;
        let size = u32::read_options(reader, endian, args)?;
        let properties = PropertyMap::read_options(reader, endian, args)?;
        let terminator = u32::read_options(reader, endian, args)?;

        assert_eq!(terminator, 0);
        assert_eq!(
            size,
            (properties.byte_size() + terminator.byte_size()) as u32
        );

        Ok(Self { name, properties })
    }
}

impl BinWrite for PropertyList {
    type Args<'a> = ();

    fn write_options<W: std::io::prelude::Write + std::io::prelude::Seek>(
        &self,
        writer: &mut W,
        endian: binrw::Endian,
        args: Self::Args<'_>,
    ) -> binrw::prelude::BinResult<()> {
        let size = (self.properties.byte_size() + u32::BYTE_SIZE) as u32;
        let terminator = 0u32;

        self.name.write_options(writer, endian, args)?;
        size.write_options(writer, endian, args)?;
        self.properties.write_options(writer, endian, args)?;
        terminator.write_options(writer, endian, args)
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupInfo {
    item_count: u32,
    group_id: u32,
}

impl BinRead for GroupInfo {
    type Args<'a> = ();

    fn read_options<R: std::io::prelude::Read + std::io::prelude::Seek>(
        reader: &mut R,
        endian: binrw::Endian,
        args: Self::Args<'_>,
    ) -> binrw::prelude::BinResult<Self> {
        Ok(Self {
            item_count: <_>::read_options(reader, endian, args)?,
            group_id: <_>::read_options(reader, endian, args)?,
        })
    }
}

impl BinWrite for GroupInfo {
    type Args<'a> = ();

    fn write_options<W: std::io::prelude::Write + std::io::prelude::Seek>(
        &self,
        writer: &mut W,
        endian: binrw::Endian,
        args: Self::Args<'_>,
    ) -> binrw::prelude::BinResult<()> {
        self.item_count.write_options(writer, endian, args)?;
        self.group_id.write_options(writer, endian, args)
    }
}

#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct SuiteBro {
    pub header: Header,
    pub items: Vec<Item>,
    pub properties: Vec<PropertyList>,
    // attribute count?
    pub unk_1: u32,
    pub groups: Vec<GroupInfo>,
}

impl BinRead for SuiteBro {
    type Args<'a> = ();

    fn read_options<R: std::io::prelude::Read + std::io::prelude::Seek>(
        reader: &mut R,
        endian: binrw::Endian,
        args: Self::Args<'_>,
    ) -> binrw::prelude::BinResult<Self> {
        let header = Header::read_options(reader, endian, args)?;

        let item_count = u32::read_options(reader, endian, args)?;
        let items = <Vec<Item>>::read_options(
            reader,
            endian,
            VecArgs {
                count: item_count as usize,
                inner: (),
            },
        )?;

        let property_count = u32::read_options(reader, endian, args)?;
        let properties = <Vec<PropertyList>>::read_options(
            reader,
            endian,
            VecArgs {
                count: property_count as usize,
                inner: (),
            },
        )?;

        let unk_1 = u32::read_options(reader, endian, args)?;

        let group_count = u32::read_options(reader, endian, args)?;
        let groups = <Vec<GroupInfo>>::read_options(
            reader,
            endian,
            VecArgs {
                count: group_count as usize,
                inner: (),
            },
        )?;

        Ok(Self {
            header,
            items,
            properties,
            unk_1,
            groups,
        })
    }
}

impl BinWrite for SuiteBro {
    type Args<'a> = ();

    fn write_options<W: std::io::prelude::Write + std::io::prelude::Seek>(
        &self,
        writer: &mut W,
        endian: binrw::Endian,
        args: Self::Args<'_>,
    ) -> binrw::prelude::BinResult<()> {
        let item_count = self.items.len() as u32;
        let property_count = self.properties.len() as u32;
        let group_count = self.groups.len() as u32;

        self.header.write_options(writer, endian, args)?;
        item_count.write_options(writer, endian, args)?;
        self.items.write_options(writer, endian, args)?;
        property_count.write_options(writer, endian, args)?;
        self.properties.write_options(writer, endian, args)?;
        self.unk_1.write_options(writer, endian, args)?;
        group_count.write_options(writer, endian, args)?;
        self.groups.write_options(writer, endian, args)
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    use binrw::{BinReaderExt, BinWriterExt};
    use std::{error::Error, io::Cursor};

    macro_rules! test_rw {
        ($name:ident, $ty:ty, $input:expr) => {
            #[test]
            fn $name() -> Result<(), Box<dyn Error>> {
                let input = $input;
                let mut reader = Cursor::new(&input);

                let mut output = vec![];
                let mut writer = Cursor::new(&mut output);

                let value: $ty = reader.read_le()?;
                writer.write_le(&value)?;

                // let decoded: $ty = writer.read_le()?;
                assert_eq!(&input[..], &output[..]);

                // assert_eq!(value, decoded);

                Ok(())
            }
        };
    }

    test_rw!(
        test_header,
        Header,
        [
            0x73, 0x75, 0x69, 0x74, 0x65, 0x62, 0x72, 0x6F, 0x01, 0x00, 0x00, 0x00, 0x05, 0x02,
            0x00, 0x00,
        ]
    );

    test_rw!(
        test_item,
        item::Items,
        [
            0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x41, 0x75, 0x64, 0x69, 0x6F, 0x44,
            0x69, 0x66, 0x66, 0x75, 0x73, 0x65, 0x72, 0x50, 0x6C, 0x61, 0x73, 0x74, 0x69, 0x63,
            0x00, 0x5E, 0x77, 0xC5, 0x59, 0x22, 0x90, 0x1E, 0x4F, 0x94, 0xF3, 0x45, 0xCB, 0xB4,
            0x56, 0xFA, 0x76, 0x01, 0x00, 0x00, 0x00, 0x74, 0x2D, 0xBB, 0x45, 0x8D, 0x17, 0x5E,
            0x36, 0x08, 0x01, 0x00, 0x00, 0x74, 0x69, 0x6E, 0x79, 0x72, 0x69, 0x63, 0x6B, 0x01,
            0x00, 0x00, 0x00, 0x05, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x43, 0x6F, 0x6C,
            0x6F, 0x72, 0x73, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50,
            0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x5B, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72,
            0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00,
            0x00, 0x00, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x73, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53,
            0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
            0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x4C, 0x69,
            0x6E, 0x65, 0x61, 0x72, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80,
            0x3F, 0x0E, 0x00, 0x00, 0x00, 0x4F, 0x77, 0x6E, 0x69, 0x6E, 0x67, 0x53, 0x74, 0x65,
            0x61, 0x6D, 0x49, 0x44, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63,
            0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x09, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x53, 0x74, 0x65, 0x61, 0x6D, 0x49,
            0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00,
            0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x20, 0xA7, 0x44, 0x00, 0x20, 0xA7, 0x44, 0x00,
            0x20, 0xA7, 0x44, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80,
            0x3F
        ]
    );

    test_rw!(
        test_property,
        PropertyList,
        [
            0x12, 0x00, 0x00, 0x00, 0x43, 0x6F, 0x6E, 0x64, 0x6F, 0x57, 0x65, 0x61, 0x74, 0x68,
            0x65, 0x72, 0x5F, 0x32, 0x37, 0x32, 0x39, 0x00, 0x49, 0x03, 0x00, 0x00, 0x18, 0x00,
            0x00, 0x00, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x6F, 0x6E, 0x66, 0x69,
            0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x4E, 0x65, 0x77, 0x00, 0x0F, 0x00,
            0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72,
            0x74, 0x79, 0x00, 0x63, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00,
            0x00, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x4D, 0x61, 0x6E, 0x69, 0x66, 0x65,
            0x73, 0x74, 0x45, 0x6E, 0x74, 0x72, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00,
            0x00, 0x43, 0x6C, 0x6F, 0x75, 0x64, 0x49, 0x6E, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x74,
            0x79, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F,
            0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x46, 0x6F, 0x67, 0x49, 0x6E,
            0x74, 0x65, 0x6E, 0x73, 0x69, 0x74, 0x79, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x46, 0x6C,
            0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00,
            0x00, 0x52, 0x61, 0x69, 0x6E, 0x49, 0x6E, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x74, 0x79,
            0x00, 0x0E, 0x00, 0x00, 0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F, 0x70,
            0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x54, 0x68, 0x75, 0x6E, 0x64, 0x65,
            0x72, 0x49, 0x6E, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x74, 0x79, 0x00, 0x0E, 0x00, 0x00,
            0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,
            0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0E, 0x00, 0x00, 0x00, 0x53, 0x6E, 0x6F, 0x77, 0x49, 0x6E, 0x74, 0x65, 0x6E, 0x73,
            0x69, 0x74, 0x79, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50,
            0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x48, 0x61, 0x69,
            0x6C, 0x49, 0x6E, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x74, 0x79, 0x00, 0x0E, 0x00, 0x00,
            0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,
            0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x0E, 0x00, 0x00, 0x00, 0x57, 0x69, 0x6E, 0x64, 0x49, 0x6E, 0x74, 0x65, 0x6E, 0x73,
            0x69, 0x74, 0x79, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50,
            0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E,
            0x65, 0x00, 0x16, 0x00, 0x00, 0x00, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x54,
            0x72, 0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x54, 0x69, 0x6D, 0x65, 0x00,
            0x0E, 0x00, 0x00, 0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65,
            0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x20, 0x41, 0x16, 0x00, 0x00, 0x00, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72,
            0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C,
            0x00, 0x0E, 0x00, 0x00, 0x00, 0x46, 0x6C, 0x6F, 0x61, 0x74, 0x50, 0x72, 0x6F, 0x70,
            0x65, 0x72, 0x74, 0x79, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xF0, 0x41, 0x1E, 0x00, 0x00, 0x00, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65,
            0x72, 0x43, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E,
            0x43, 0x68, 0x65, 0x63, 0x6B, 0x6C, 0x69, 0x73, 0x74, 0x00, 0x0E, 0x00, 0x00, 0x00,
            0x41, 0x72, 0x72, 0x61, 0x79, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
            0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x42, 0x6F,
            0x6F, 0x6C, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x18, 0x00,
            0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1C, 0x00,
            0x00, 0x00, 0x54, 0x72, 0x75, 0x6C, 0x79, 0x52, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x57,
            0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x53, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F,
            0x6E, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x42, 0x6F, 0x6F, 0x6C, 0x50, 0x72, 0x6F, 0x70,
            0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x15, 0x00, 0x00, 0x00, 0x57, 0x65, 0x61, 0x74, 0x68, 0x65, 0x72, 0x43, 0x79,
            0x63, 0x6C, 0x65, 0x72, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x00, 0x0D, 0x00,
            0x00, 0x00, 0x42, 0x6F, 0x6F, 0x6C, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00,
            0x00, 0x62, 0x43, 0x61, 0x6E, 0x42, 0x65, 0x44, 0x61, 0x6D, 0x61, 0x67, 0x65, 0x64,
            0x00, 0x0D, 0x00, 0x00, 0x00, 0x42, 0x6F, 0x6F, 0x6C, 0x50, 0x72, 0x6F, 0x70, 0x65,
            0x72, 0x74, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
        ]
    );

    test_rw!(
        test_suitebro,
        SuiteBro,
        include_bytes!("../../assets/OneItem")
    );
}
