use binrw::binrw;
use serde::{Deserialize, Serialize};

use crate::{byte_size::ByteSize, gvas::types::FString};

use self::{item::Item, property_map::PropertyMap};

pub mod item;
pub mod property_map;

#[binrw]
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
#[brw(magic = b"suitebro")]
pub struct Header {
    pub format_version: u32,
    pub unreal_version: u32,
}

// idk
#[binrw]
#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct PropertyList {
    pub name: FString,
    #[br(temp)]
    #[bw(calc = 4 + self.properties.byte_size() as u32)]
    pub size: u32,
    pub properties: PropertyMap,
    #[br(temp, assert(terminator == 0))]
    #[bw(calc = 0)]
    pub terminator: u32,
}

#[binrw]
#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct GroupInfo {
    item_count: u32,
    group_id: u32,
}

#[binrw]
#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct SuiteBro {
    pub header: Header,
    #[br(temp)]
    #[bw(calc = items.len() as u32)]
    pub item_count: u32,
    #[br(count = item_count)]
    pub items: Vec<Item>,
    #[br(temp)]
    #[bw(calc = properties.len() as u32)]
    pub property_count: u32,
    #[br(count = property_count)]
    pub properties: Vec<PropertyList>,

    // attribute count?
    pub unk_1: u32,

    #[br(temp)]
    #[bw(calc = groups.len() as u32)]
    pub group_count: u32,
    #[br(count = group_count)]
    pub groups: Vec<GroupInfo>,
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    use binrw::{BinReaderExt, BinWriterExt};
    use std::{error::Error, io::Cursor};

    macro_rules! test_rw {
        ($name:ident, $ty:ty, $input:expr) => {
            #[test]
            fn $name() -> Result<(), Box<dyn Error>> {
                let input = $input;
                let mut reader = Cursor::new(&input);

                let mut output = vec![];
                let mut writer = Cursor::new(&mut output);

                let value: $ty = reader.read_le()?;
                writer.write_le(&value)?;

                // let decoded: $ty = writer.read_le()?;
                assert_eq!(&input[..], &output[..]);

                // assert_eq!(value, decoded);

                Ok(())
            }
        };
    }

    test_rw!(
        test_header,
        Header,
        [
            0x73, 0x75, 0x69, 0x74, 0x65, 0x62, 0x72, 0x6F, 0x01, 0x00, 0x00, 0x00, 0x05, 0x02,
            0x00, 0x00,
        ]
    );

    test_rw!(
        test_item,
        item::Items,
        [
            0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x41, 0x75, 0x64, 0x69, 0x6F, 0x44,
            0x69, 0x66, 0x66, 0x75, 0x73, 0x65, 0x72, 0x50, 0x6C, 0x61, 0x73, 0x74, 0x69, 0x63,
            0x00, 0x5E, 0x77, 0xC5, 0x59, 0x22, 0x90, 0x1E, 0x4F, 0x94, 0xF3, 0x45, 0xCB, 0xB4,
            0x56, 0xFA, 0x76, 0x01, 0x00, 0x00, 0x00, 0x74, 0x2D, 0xBB, 0x45, 0x8D, 0x17, 0x5E,
            0x36, 0x08, 0x01, 0x00, 0x00, 0x74, 0x69, 0x6E, 0x79, 0x72, 0x69, 0x63, 0x6B, 0x01,
            0x00, 0x00, 0x00, 0x05, 0x02, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x43, 0x6F, 0x6C,
            0x6F, 0x72, 0x73, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x41, 0x72, 0x72, 0x61, 0x79, 0x50,
            0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x5B, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72,
            0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00,
            0x00, 0x00, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x73, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53,
            0x74, 0x72, 0x75, 0x63, 0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00,
            0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x4C, 0x69,
            0x6E, 0x65, 0x61, 0x72, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80,
            0x3F, 0x0E, 0x00, 0x00, 0x00, 0x4F, 0x77, 0x6E, 0x69, 0x6E, 0x67, 0x53, 0x74, 0x65,
            0x61, 0x6D, 0x49, 0x44, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x74, 0x72, 0x75, 0x63,
            0x74, 0x50, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x09, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x53, 0x74, 0x65, 0x61, 0x6D, 0x49,
            0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00,
            0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x20, 0xA7, 0x44, 0x00, 0x20, 0xA7, 0x44, 0x00,
            0x20, 0xA7, 0x44, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80,
            0x3F
        ]
    );

    test_rw!(
        test_suitebro,
        SuiteBro,
        include_bytes!("../../assets/OneItem")
    );
}
